<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shared Pixel Canvas</title>
<style>
  body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin:0; padding:20px; background:#f0f0f0; }
  canvas { border:1px solid #000; image-rendering: pixelated; cursor: crosshair; }
  #controls { margin-bottom: 10px; display: flex; gap: 10px; align-items: center; }
  #info { font-weight: bold; margin-top: 10px; }
</style>
</head>
<body>
<h1>Shared Pixel Canvas</h1>
<div id="controls">
  <label>Color <input type="color" id="color" value="#ff0000"></label>
  <label>Pixel size
    <select id="pxSize">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
    </select>
  </label>
</div>
<canvas id="canvas"></canvas>
<div id="info">Pixels left: 10 | Next reset: â€”</div>

<script type="module">
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = "https://pemfxpowmsajsxsveoli.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBlbGZ4cG93bXNhanN4c3Zlb2xpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3NjYyNzMsImV4cCI6MjA3MTM0MjI3M30.SJBgs4kQTqyn6S6A3usxTHaWK-nb2R51DMznT6geA_M";

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorInput = document.getElementById('color');
const sizeSelect = document.getElementById('pxSize');
const info = document.getElementById('info');
canvas.width = 1000; // adjust as needed
canvas.height = 600;

// Token bucket
let tokens = 10;
const CAPACITY = 10;
const REFILL_MS = 60000; // 1 token per min
function updateInfo(){ info.textContent = `Pixels left: ${tokens} | Next reset: ${countdownText}`; }
setInterval(()=>{ if(tokens<CAPACITY) tokens++; updateInfo(); }, REFILL_MS);

// Pixel state
const pixels = new Map();
function drawPixel(x,y,color){ const size=parseInt(sizeSelect.value)||1; ctx.fillStyle=color; ctx.fillRect(x,y,size,size); }
function key(x,y){ return `${x}_${y}`; }

// Load existing pixels
async function loadPixels(){
  const { data } = await supabase.from('pixels').select('*');
  if(data) data.forEach(p=>{ const k=key(p.x,p.y); pixels.set(k,p.color); drawPixel(p.x,p.y,p.color); });
}

// Real-time updates
supabase.channel('public:pixels')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'pixels'},payload=>{
    const p=payload.new; const k=key(p.x,p.y);
    if(!pixels.has(k)){ pixels.set(k,p.color); drawPixel(p.x,p.y,p.color); }
  }).subscribe();

// Place pixel
async function placePixel(x,y,color){
  const k=key(x,y);
  if(pixels.has(k)) return;
  if(tokens<=0){ alert("No pixels left!"); return; }
  tokens--;
  pixels.set(k,color);
  drawPixel(x,y,color);
  updateInfo();
  await supabase.from('pixels').insert({x,y,color});
}

// Mouse events
canvas.addEventListener('pointerdown',e=>{ paint(e); });
canvas.addEventListener('pointermove',e=>{ if(e.buttons) paint(e); });
function paint(e){
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor(e.clientX-rect.left);
  const y=Math.floor(e.clientY-rect.top);
  placePixel(x,y,colorInput.value);
}

// Daily reset
function getNextReset(){
  const now=new Date();
  const utc=now.getTime() + now.getTimezoneOffset()*60000;
  const israelOffset=3*60*60000;
  const israelNow=new Date(utc+israelOffset);
  const next=new Date(israelNow);
  next.setHours(24,0,0,0);
  return new Date(next.getTime()-israelOffset);
}
let nextReset = getNextReset();
let countdownText = '';
async function resetCanvas(){
  await supabase.from('pixels').delete().neq('id',0);
  pixels.clear();
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
}
function updateCountdown(){
  const now=new Date();
  const diff = nextReset-now;
  if(diff<=0){ resetCanvas(); nextReset=getNextReset(); }
  const s=Math.floor(diff/1000); const h=String(Math.floor(s/3600)).padStart(2,'0'); const m=String(Math.floor((s%3600)/60)).padStart(2,'0'); const sec=String(s%60).padStart(2,'0');
  countdownText = `${h}:${m}:${sec}`;
  updateInfo();
}
setInterval(updateCountdown,1000);

// Init
window.addEventListener('load',()=>{ ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); loadPixels(); updateCountdown(); updateInfo(); });
</script>
</body>
</html>
